
# Домашнее задание №1

При выполнении заданий **не используйте** присваивание и циклы.
Избегайте возврата логических значений из условных конструкций.
Подготовьте примеры для демонстрации работы разработанных вами процедур.

## 1. Определение дня недели по дате

Определите процедуру `day-of-week`, вычисляющую день недели по дате по
григорианскому календарю. Воспользуйтесь алгоритмом, описанным в
литературе. Пусть процедура принимает три формальных аргумента (день
месяца, месяц и год в виде целых чисел) и возвращает целое число — номер
дня в неделе (0 — воскресенье, 1 — понедельник, … 6 — суббота).

Пример вызова процедуры:

``` example
(day-of-week 04 12 1975) ⇒ 4
(day-of-week 04 12 2006) ⇒ 1
(day-of-week 29 05 2013) ⇒ 3
```

``` scheme
(define (day-of-week day month year)
  (set! month (remainder (+ month 10) 12) )
  (cond ((= month 0)
         (inexact->exact (modulo (+
                                  day
                                  (floor (- (* 2.6 12) 0.2))
                                  (* (quotient year 100) -2)
                                  (- (modulo year 100) 1)
                                  (quotient (- (modulo year 100) 1) 4)
                                  (quotient (quotient year 100) 4)) 7)))

      ((= month 11) (inexact->exact (modulo (+
                                             day
                                             (floor (- (* 2.6 month) 0.2))
                                             (* (quotient year 100) -2)
                                             (- (modulo year 100) 1)
                                             (quotient (- (modulo year 100) 1) 4)
                                             (quotient (quotient year 100) 4)) 7)))
      
      (else (inexact->exact (modulo (+
                                     day
                                     (floor (- (* 2.6 month) 0.2))
                                     (* (quotient year 100) -2)
                                     (modulo year 100)
                                     (quotient (modulo year 100) 4)
                                     (quotient (quotient year 100) 4)) 7)))))
```

## 2. Действительные корни квадратного уравнения

Определите процедуру, принимающую коэффициенты *a*, *b* и *c*
квадратного уравнения вида /ax/²+/bx/+/c/=0 и возвращающую список чисел
— корней уравнения (один или два корня, или пустой список, если корней
нет).

**Указание:** для формирования списка используйте функцию `(list …)`:

``` example
(list)        → ()
(list 10)     → (10)
(list 10 11)  → (10 11)
```

``` scheme
(define (square-equation a b c)
    (cond
        ( (= 0 (D a b c)) (list (/ (- b) (* 2 a))))
        ( (> (D a b c) 0) (list (/ (+ (- b) (sqrt (D a b c))) (* 2 a)) (/ (- (- b) (sqrt (D a b c))) (* 2 a)) ))
        (else '())))

(define (D a b c)
    (- (* b b) (* 4 a c)))
```


## 3. НОД, НОК и проверка числа на простоту

Определите:

-   Процедуру `(my-gcd a b)`, возвращающую наибольший общий делитель
    чисел `a` и `b`. Поведение вашей процедуры должно быть идентично
    поведению встроенной процедуры `gcd`.

-   Процедуру `(my-lcm a b)`, возвращающую наименьшее общее кратное
    чисел `a` и `b`. Используйте процедуру `my-gcd`, определенную вами
    ранее. Поведение вашей процедуры должно быть идентично поведению
    встроенной процедуры `lcm`.

-   Процедуру `(prime? n)`, выполняющую проверку числа `n` на простоту и
    возвращающую `#t`, если число простое и `#f` в противном случае.

-   Примеры вызова процедур:

``` example
(my-gcd 3542 2464) ⇒ 154
(my-lcm 3 4)       ⇒  12
(prime? 11)        ⇒  #t
(prime? 12)        ⇒  #f
```

``` scheme
(define (my-gcd a b) 
(define (my-gcd-positive a b)
    (if (= b 0)
        a
        (my-gcd-positive b (remainder a b))))
(my-gcd-positive (abs a) (abs b)))


(define (my-lcm a b)
(/ (* (abs a) (abs b)) (my-gcd a b)))


(define (prime? n)
    (let loop ((n n)
                (cur (- n 1)))
        (cond
            ((<= n 1) #f)
            ((<= cur 1) #t)
            ((= (/ n cur) (quotient n cur) ) #f)
            (else (loop n (- cur 1)) ))))
```
